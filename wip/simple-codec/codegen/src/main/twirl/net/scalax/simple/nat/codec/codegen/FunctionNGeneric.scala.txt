@()
package net.scalax.simple.codec

object impl {

private sealed trait InnerHList {
  def ::[Head](h: Head): InnerHPositive[Head, InnerHList] = new InnerHPositive(h, this)
}

private class InnerHPositive[+H, +T <: InnerHList](val head : H, val tail : T) extends InnerHList {
  override def ::[Head](h: Head): InnerHPositive[Head, InnerHPositive[H, T]] = new InnerHPositive(h, this)
}

private sealed trait InnerHZero extends InnerHList {
  override def ::[Head](h: Head): InnerHPositive[Head, InnerHZero] = new InnerHPositive(h, InnerHZero)
}

private case object InnerHZero extends InnerHZero

private type ::[+H, +T <: InnerHList] = InnerHPositive[H, T]

@for(i <- 3 to 50) {

  trait Function@{i}GenericImpl[F[_[_]]] extends Function50Generic[F] {
    self =>

    override def function@{i}[@for(i1 <- 1 to i) { T@{i1}[_], } TOut[_]](func: Function@{i}Apply[@for(i1 <- 1 to i) { T@{i1}, } TOut])(
      @for(i1 <- 1 to i - 1) { t@{i1}: F[T@{i1}], } t@{i}: F[T@{i}]
    ): F[TOut] = {
      type ZipType[U] = @for(i1 <- 1 to i - 1) { T@{i1}[U] :: } InnerHZero
      val func2: Function2Apply[ZipType, T@{i}, TOut] = new Function2Apply[ZipType, T@{i}, TOut] {
        override def apply[X](param1: @for(i1 <- 1 to i - 1) { T@{i1}[X] :: } InnerHZero, i2: T@{i}[X]): TOut[X] =
          func(@for(i1 <- 0 to i - 2) { param1 @for(i2 <- 1 to i1) { .tail } .head , } i2)
      }
      val func3: Function@{i - 1}Apply[@for(i1 <- 1 to i - 1) { T@{i1}, } ZipType] = new Function@{i - 1}Apply[@for(i1 <- 1 to i - 1) { T@{i1}, } ZipType] {
        override def apply[X](@for(i1 <- 1 to i - 2) { t@{i1}: T@{i1}[X], } t@{i - 1}: T@{i - 1}[X]): @for(i1 <- 1 to i - 1) { T@{i1}[X] :: } InnerHZero = @for(i1 <- 1 to i - 1) { t@{i1} :: } InnerHZero
      }
      val temp2: F[ZipType] = self.function@{i - 1}(func3)(@for(i1 <- 1 to i - 2) { t@{i1}, } t@{i - 1})
      self.function2(func2)(temp2, t@{i})
    }
  }

}

trait FunctionNGenericSumImpl[F[_[_]]] extends Function50Generic[F] @for(i <- 3 to 50) { with impl.Function@{i}GenericImpl[F] }

}

